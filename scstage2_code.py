# -*- coding: utf-8 -*-
"""SCstage2_code.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1z0qsgOx3uvbBQJCtK6p-47Yty7XYoVFx

# Single-Cell RNA-seq Analysis of a Bone-Marrow Dataset
### Install required packages
"""

#Installations and importing libraries

!pip install scanpy anndata decoupler celltypist igraph fa2-modified crc32c

# Import essential libraries for single‑cell analysis
import scanpy as sc
import pandas as pd
import decoupler as dc
import seaborn as sns
import matplotlib.pyplot as plt

sc.settings.verbosity = 3
sc.settings.set_figure_params(dpi=100)

#loading data
!wget -O bone_marrow.h5ad https://github.com/josoga2/sc/raw/refs/heads/main/bone_marrow.h5ad
bm_adata = sc.read("bone_marrow.h5ad")
bm_adata

# check for dimensions of our dataset
bm_adata.shape

#first 5 rows describing the cells ID in our dataset
bm_adata.obs.head()

#first 5 rows describing the genes in our dataset
bm_adata.var.head()

#Quality Control (QC)
#identify mitochondrial, ribosomal and hemoglobin genes for per-cell QC metrics.
bm_adata.var_names_make_unique()
bm_adata.obs_names_make_unique()

# Annotate mitochondrial, ribosomal, and hemoglobin genes
bm_adata.var["MT"] = bm_adata.var_names.str.startswith("MT-")
bm_adata.var["RIBO"] = bm_adata.var_names.str.startswith(("RPS", "RPL"))
bm_adata.var["HB"] = bm_adata.var_names.str.startswith("HB")

sc.pp.calculate_qc_metrics(
    bm_adata, qc_vars=["MT", "RIBO", "HB"], inplace=True
)

# Define specific hemoglobin marker list
hb_gene_list = ['HBA1', 'HBA2', 'HBB', 'HBD', 'HBG1', 'HBG2']

sym_upper = bm_adata.var_names.str.upper()

#sym_upper = bm_adata.var_names.str.upper()
#bm_adata.var['MT'] = bm_adata.var_names.str.startswith("MT-")
#bm_adata.var['RIBO'] = bm_adata.var_names.str.startswith(("RPS", "RPL"))
#bm_adata.var['HB'] = sym_upper.isin(hb_gene_list)

bm_adata.var[['MT', 'RIBO', 'HB']].sum()

sc.pp.calculate_qc_metrics(
    bm_adata, qc_vars=["MT", 'RIBO', 'HB'], inplace=True, log1p=True
)

bm_adata.obs.head()

bm_adata.var.head()

# Filter out low-quality cells and genes
sc.pp.filter_cells(bm_adata, min_genes=200) # Remove cells expressing <200 genes
sc.pp.filter_genes(bm_adata, min_cells=3)   # Remove genes expressing <3 genes

"""### Remove cells with high mitochondrial / ribosomal / hemoglobin content"""

bm_adata = bm_adata[bm_adata.obs['pct_counts_MT'] < 20, :].copy()

bm_adata = bm_adata[bm_adata.obs['pct_counts_RIBO'] < 20, :].copy()

bm_adata = bm_adata[bm_adata.obs['pct_counts_HB'] < 20, :].copy()

"""### Quality Control visualizations"""

sc.pl.violin(bm_adata, ["n_genes_by_counts", "total_counts", "pct_counts_MT"], multi_panel=True)

sc.pl.scatter(bm_adata, "total_counts", "n_genes_by_counts", color="pct_counts_MT")

sc.pl.scatter(bm_adata, "total_counts", "n_genes_by_counts", color="pct_counts_RIBO")

sc.pl.scatter(bm_adata, "total_counts", "n_genes_by_counts", color="pct_counts_HB")

bm_adata.obs.columns

# Doublet Detection (Scrublet)
!pip install scrublet

import scrublet as scr
import scipy.sparse as sp

# Perform Scanpy scrublet wrapper
sc.pp.scrublet(bm_adata)

# Extract counts matrix for manual Scrublet run
if "counts" in bm_adata.layers:
    counts_matrix = bm_adata.layers["counts"]
else:
    counts_matrix = bm_adata.X

# Convert sparse matrix to dense
if sp.issparse(counts_matrix):
    counts_matrix = counts_matrix.toarray()

# Initialize Scrublet with expected doublet rate
scrub = scr.Scrublet(
    counts_matrix,
    expected_doublet_rate=0.06  # 6% prior; fine for coursework unless told otherwise
)

# Run doublet prediction
doublet_scores, predicted_doublets = scrub.scrub_doublets()

bm_adata.obs["doublet_score"] = doublet_scores
bm_adata.obs["predicted_doublet"] = predicted_doublets

bm_adata.obs[["doublet_score", "predicted_doublet"]].head()

# Store results in AnnData
bm_adata.obs['predicted_doublet'] = bm_adata.obs['predicted_doublet'].astype('category')

# Visualize QC distribution for predicted doublets
sc.pl.violin(
    bm_adata,
    ["n_genes_by_counts", "total_counts"],
    groupby="predicted_doublet",
    multi_panel=True
)

# Filter out predicted doublets
before = bm_adata.n_obs
bm_adata = bm_adata[bm_adata.obs["predicted_doublet"] == False].copy()
after = bm_adata.n_obs

print(f"Removed {before - after} predicted doublets; remaining {after} cells.")

# Normalization, Log Transform & HVGs
# Store raw counts
bm_adata.obs['predicted_doublet'] = bm_adata.obs['predicted_doublet'].astype('category')
sc.pl.violin(
    bm_adata,
    ["n_genes_by_counts", "total_counts"],
    groupby="predicted_doublet",
    multi_panel=True
)

#Normalization, log-transform and highly variable genes
#Why: stabilize variance and focus on informative genes for downstream dimensionality reduction.

#
bm_adata.layers["counts"] = bm_adata.X.copy()

sc.pp.normalize_total(bm_adata)
sc.pp.log1p(bm_adata)

sc.pp.highly_variable_genes(bm_adata, n_top_genes=1000)

sc.pl.highly_variable_genes(bm_adata)

sc.tl.pca(bm_adata)
sc.pl.pca_variance_ratio(bm_adata, n_pcs=10, log=False)

sc.pl.pca(
    bm_adata,
    color=["pct_counts_MT"]
)

sc.pp.neighbors(bm_adata)
sc.tl.umap(bm_adata)

sc.pl.umap(
    bm_adata,
    color=["pct_counts_RIBO"],
    size=8,
)

sc.tl.leiden(bm_adata, flavor="igraph", n_iterations=2)

sc.pl.umap(
    bm_adata,
    color=["leiden"],
    size=8,
)

sc.pl.umap(
    bm_adata,
    color=["leiden"],
    wspace=0.5,
    size=3,
    ncols = 1
)

bm_adata.obs.columns

sc.pl.umap(bm_adata, color=["leiden", "doublet_score", "predicted_doublet"])

sc.tl.leiden(bm_adata, flavor="igraph", n_iterations=2, key_added="leiden_res0_02", resolution=0.02)
sc.tl.leiden(bm_adata, flavor="igraph", n_iterations=2, key_added="leiden_res0_5", resolution=0.5)
sc.tl.leiden(bm_adata, flavor="igraph", n_iterations=2, key_added="leiden_res2", resolution=2)

sc.pl.umap(
    bm_adata,
    color=["leiden_res0_02"],
    # increase horizontal space between panels
    wspace=0.5,
    size=15,
    ncols = 1
)

sc.pl.umap(
    bm_adata,
    color=["leiden_res0_5"],
    wspace=0.5,
    size=15,
    ncols = 1,
    legend_loc="on data"
)

sc.pl.umap(
    bm_adata,
    color=["leiden_res2"],
    wspace=0.5,
    size=15,
    ncols = 1,
    legend_loc="on data"
)

#Cell-type scoring with decoupler (PanglaoDB)
#Why: use reference marker signatures to quantify how “neutrophil-like”, “B cell-like”, etc. each cell is.

# Query Omnipath and get CellMarker
markers = dc.op.resource(name="PanglaoDB", organism="human")

# Keep canonical cell type markers alone
markers = markers[markers["canonical_marker"]]

# Remove duplicated entries
markers = markers[~markers.duplicated(["cell_type", "genesymbol"])]

# Format because dc only accepts cell_type and genesymbol

markers = markers.rename(columns={"cell_type": "source", "genesymbol": "target"})
markers = markers[["source", "target"]]

markers.tail()

# Query Omnipath and get CellMarker
markers = dc.op.resource(name="PanglaoDB", organism="human")

# Keep canonical cell type markers alone
markers = markers[markers["canonical_marker"]]

# Remove duplicated entries
markers = markers[~markers.duplicated(["cell_type", "genesymbol"])]

# Format because dc only accepts cell_type and genesymbol
markers = markers.rename(columns={"cell_type": "source", "genesymbol": "target"})
markers = markers[["source", "target"]]

# Convert 'feature_name' column to a plain Index of strings before assigning to var_names
bm_adata.var_names = pd.Index(bm_adata.var['feature_name'].astype(str))
bm_adata.var_names_make_unique()

dc.mt.ulm(data=bm_adata,
          net=markers,
          tmin = 3)

# retrieve the score for each cell type
score = dc.pp.get_obsm(bm_adata, key="score_ulm")

sc.pl.dotplot(
    score, # Use the 'score' AnnData object directly
    var_names=score.var_names.tolist(), # List of cell types (features)
    groupby='leiden_res0_5',
    cmap='RdBu_r', # A common colourmap for scores
    dendrogram=True,
    standard_scale='var', # Scale scores for better visualisation
    title='Cell Type Scores by Leiden Clusters'
)

#preview the data
bm_adata.obsm["score_ulm"].head()

bm_adata.obsm["score_ulm"].columns

sc.pl.umap(score, color=["NK cells", "leiden_res2"], cmap="RdBu_r")

sc.pl.umap(score, color=["NK cells", "leiden_res0_5"], cmap="RdBu_r")

#Cluster annotation and visualisation
#Why: assign human-readable cell-type labels to clusters and interpret the cellular composition.

# Get cell-type scores as DataFrame
score = dc.pp.get_obsm(bm_adata, key="score_ulm")

#Rank signatures per cluster for your main clustering
rank_df = dc.tl.rankby_group(
    score,
    groupby="leiden_res2",  # use the same clustering
    reference="rest",
    method="t-test_overestim_var",
)

#Take top signature per cluster
cluster_auto = (
    rank_df
    .sort_values(["group", "stat"], ascending=[True, False])
    .groupby("group")
    .head(1)
    .set_index("group")["name"]   # 'name' = signature (e.g. "Neutrophils")
    .to_dict()
)

cluster_auto

bm_adata.obs["cell_type"] = (
    bm_adata.obs["leiden_res2"].map(cluster_auto)
).astype("category")

sc.pl.umap(bm_adata, color=["cell_type"], legend_loc="on data")

#Get cell-type scores as DataFrame
score = dc.pp.get_obsm(bm_adata, key="score_ulm")

# Rank signatures per cluster for your main clustering
rank_df = dc.tl.rankby_group(
    score,
    groupby="leiden_res0_02",  # use the same clustering
    reference="rest",
    method="t-test_overestim_var",
)

# Keep only positive stats (enriched vs rest)
rank_df = rank_df[rank_df["stat"] > 0]

# Take top signature per cluster
cluster_auto = (
    rank_df
    .sort_values(["group", "stat"], ascending=[True, False])
    .groupby("group")
    .head(1)
    .set_index("group")["name"]   # 'name' = signature (e.g. "Neutrophils")
    .to_dict()
)

cluster_auto

bm_adata.obs["cell_type_auto"] = (
    bm_adata.obs["leiden_res0_02"].map(cluster_auto)
).astype("category")

sc.pl.umap(bm_adata, color=["cell_type_auto"], legend_loc="on data")

# Get cell-type scores as DataFrame
score = dc.pp.get_obsm(bm_adata, key="score_ulm")

# Rank signatures per cluster for your main clustering
rank_df = dc.tl.rankby_group(
    score,
    groupby="leiden_res0_5",  # use the same clustering
    reference="rest",
    method="t-test_overestim_var",
)

# Keep only positive stats (enriched vs rest)
rank_df = rank_df[rank_df["stat"] > 0]

# Take top signature per cluster
cluster_auto = (
    rank_df
    .sort_values(["group", "stat"], ascending=[True, False])
    .groupby("group")
    .head(1)
    .set_index("group")["name"]   # 'name' = signature (e.g. "Neutrophils")
    .to_dict()
)

cluster_auto

bm_adata.obs["cell_type"] = (
    bm_adata.obs["leiden_res0_5"].map(cluster_auto)
).astype("category")

sc.pl.umap(bm_adata, color=["cell_type"], legend_loc="on data")

sc.pl.violin(score, keys=["Neutrophils"], groupby="leiden_res0_5", rotation=90)

sc.pl.violin(score, keys=["NK cells"], groupby="leiden_res0_5", rotation=90)

sc.pl.violin(score, keys=["Plasma cells"], groupby="leiden_res0_5", rotation=90)

sc.pl.violin(score, keys=["B cells naive"], groupby="leiden_res0_5", rotation=90)

sc.pl.violin(score, keys=["Nuocytes"], groupby="leiden_res0_5", rotation=90)

"""# Automatic Cluster Annotation
### Rank signatures per cluster and assign top cell-type label
"""

#rank genes
bm_adata_rank = dc.tl.rankby_group(score, groupby="leiden_res0_02", reference="rest", method="t-test_overestim_var")
bm_adata_rank = bm_adata_rank[bm_adata_rank["stat"] > 0]

#rank genes
bm_adata_rank = dc.tl.rankby_group(score, groupby="leiden_res0_5", reference="rest", method="t-test_overestim_var")
bm_adata_rank = bm_adata_rank[bm_adata_rank["stat"] > 0]
bm_adata_rank.head()

#rank genes
bm_adata_rank = dc.tl.rankby_group(score, groupby="leiden_res2", reference="rest", method="t-test_overestim_var")
bm_adata_rank = bm_adata_rank[bm_adata_rank["stat"] > 0]
bm_adata_rank.head()

cluster_annotations = bm_adata_rank[bm_adata_rank["stat"] > 0].groupby("group").head(1).set_index("group")["name"].to_dict()

cluster_annotations

bm_adata.obs['cell_type'] = bm_adata.obs['leiden_res0_02'].map(cluster_annotations)

bm_adata.obs['cell_type'] = bm_adata.obs['leiden_res0_5'].map(cluster_annotations)

bm_adata.obs['cell_type'] = bm_adata.obs['leiden_res2'].map(cluster_annotations)

"""# Marker Gene Visualization
### Extract subsets of markers and plot matrixplots & tracksplots
"""

available_genes = set(bm_adata.var_names)

neutro_markers = markers[markers['source'].isin(['Neutrophils'])]['target']
neutro_markers = neutro_markers[neutro_markers.isin(available_genes)]

macro_markers = markers[markers['source'].isin(['Macrophages'])]['target']
macro_markers = macro_markers[macro_markers.isin(available_genes)]

den_cells_markers = markers[markers['source'].isin(['Dendritic cells'])]['target']
den_cells_markers = den_cells_markers[den_cells_markers.isin(available_genes)]

kup_cells_markers = markers[markers['source'].isin(['Kupffer cells'])]['target']
kup_cells_markers = kup_cells_markers[kup_cells_markers.isin(available_genes)]

micro_markers = markers[markers['source'].isin(['Microglia'])]['target']
micro_markers = micro_markers[micro_markers.isin(available_genes)]

marker_genes_dict = {
    "Neutrophils":neutro_markers.head().tolist(),
    "Macrophages": macro_markers.head().tolist(),
    "Dendritic cells": den_cells_markers.head().tolist(),
     "Kupffer cells": kup_cells_markers.head().tolist(),
     "Microglia": micro_markers.head().tolist()
}

sc.tl.dendrogram

sc.tl.dendrogram(bm_adata, groupby="leiden_res0_5")
sc.pl.matrixplot(
    bm_adata,
    marker_genes_dict,
    "leiden_res0_5",
    dendrogram=True,
    cmap="Greens",
    use_raw=False
)

sc.tl.dendrogram(bm_adata, groupby="leiden_res0_02")
sc.pl.matrixplot(
    bm_adata,
    marker_genes_dict,
    "leiden_res0_02",
    dendrogram=True,
    cmap="Blues",
    use_raw=False
)

sc.tl.dendrogram(bm_adata, groupby="leiden_res2")
sc.pl.matrixplot(
    bm_adata,
    marker_genes_dict,
    "leiden_res2",
    dendrogram=True,
    cmap="Reds",
    use_raw=False
)

sc.pl.tracksplot(bm_adata, marker_genes_dict, groupby="leiden_res2", dendrogram=False, use_raw=False)

bm_adata.var.index = bm_adata.var.index.astype(str)
bm_adata.var_names_make_unique()
sc.pl.tracksplot(bm_adata, marker_genes_dict, groupby="leiden_res0_5", dendrogram=False, use_raw=False)

bm_adata.var.index = bm_adata.var.index.astype(str)
bm_adata.var_names_make_unique()
sc.pl.tracksplot(bm_adata, marker_genes_dict, groupby="leiden_res0_02", dendrogram=False, use_raw=False)

# Final distribution of cell types
(
      bm_adata.obs["cell_type"]
    .value_counts(normalize=True)
    .sort_values(ascending=False)
)



